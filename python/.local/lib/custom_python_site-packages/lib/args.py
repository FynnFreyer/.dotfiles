import os
import sys

from inspect import currentframe

from argparse import ArgumentParser, Namespace
from os.path import expanduser, expandvars
from pathlib import Path
from typing import Optional, List, Callable, TypeVar


def clean_path(path_str: str) -> Path:
    """
    Expand all environment variables and user indicators in a path, and fully resolve it.

    :param path_str: The path as a string.
    :return: The resolved path.
    """
    return Path(expanduser(expandvars(path_str))).resolve()


def existing_path(path_str: str) -> Path:
    """
    Makes sure that a path exists.

    :param path_str: The existing path.
    :raise ValueError: On nonexistent paths.
    :return: The existing path.
    """
    path = clean_path(path_str)
    if not path.exists():
        raise ValueError(f'The path "{path_str}" doesn\'t exist.')
    return path


def file_path(path_str: str) -> Path:
    """
    Makes sure that a path points to a file.

    :param path_str: The file path.
    :raise ValueError: On paths that don't point to a file.
    :return: The existing path.
    """
    path = clean_path(path_str)
    if not path.is_file():
        raise ValueError(f'The path "{path_str}" doesn\'t point to an existing file.')
    return path


def dir_path(path_str: str) -> Path:
    """
    Makes sure that a path points to a directory.

    :param path_str: The directory path.
    :raise ValueError: On paths that don't point to a directory.
    :return: The directory path.
    """
    path = clean_path(path_str)
    if not path.is_dir():
        raise ValueError(f'The path "{path_str}" doesn\'t point to an existing directory.')
    return path


def parse_args(args: Optional[List[str]] = None, parser: Optional[ArgumentParser] = None) -> Namespace:
    """
    Parse command line arguments. When using this, one needs to either define a ``get_parser`` function in the module
    from which one is calling this function, or pass in a parser via the argument.

    :param args: Optionally, a list of arguments to parse.
    :param parser: Optionally, a parser to use.
    :return: The parsed arguments.
    """

    if args is None:
        args = sys.argv[1:]

    if parser is None:
        try:
            # get get_parser from the globals of the calling stack frame
            get_parser = currentframe().f_back.f_globals["get_parser"]
            parser = get_parser()
        except NameError as e:
            raise NameError("Define a get_parser function before using parse_args, "
                            "or pass a parser via the parser parameter.") from e

    return parser.parse_args(args)


def bool_answer(question: str, default: Optional[bool] = None) -> bool:
    """
    Get an answer to a yes/no question.

    :param question: The question text.
    :param default: Optionally, a default value for no input.
    :return: The answer as a bool.
    """
    default_indicator_map = {
        True: "[Y/n]",
        False: "[y/N]",
        None: "[y/n]",
    }

    default_indicator = default_indicator_map.get(default)
    msg = f"{question} {default_indicator}\n> "

    answer_map = {
        "y": True,
        "yes": True,
        "n": False,
        "no": False,
        "": default
    }

    answer_value = None
    valid_answer = False
    while not valid_answer:
        answer = input(msg).lower()
        answer_value = answer_map.get(answer)
        valid_answer = answer_value is not None
        if not valid_answer:
            print('Please choose between "yes" and "no".')

    return answer_value


T = TypeVar("T")


def choice(question: str, options: List[T], default: Optional[T] = None) -> T:
    """
    Get a users choice from a list of options. The options may not contain ``None``.

    :param question: The question text.
    :param options: A list of options a user may choose from. These may not contain ``None``.
    :raise ValueError: If ``None`` is in options or if ``default`` is set and not in options.
    :param default: Optionally, a default choice in case of no input.
    :return: The user's choice.
    """
    if None in options:
        raise ValueError("None is not allowed as an option.")
    if default is not None and default not in options:
        raise ValueError("A default option is set, but it's not part of the choices.")

    choice_map = {
        str(i + 1): option
        for i, option
        in enumerate(options)
    }

    num_opts = []
    for num, option in choice_map.items():
        highlight = "*" if option == default else " "
        num_opts.append(f" {highlight} {num}\t{str(option)}")
    opts_msg = "\n".join(num_opts)

    explainer = "Input the appropriate number."
    if default is not None:
        explainer += " The starred (*) entry is the default."
        choice_map[""] = default

    msg = f"{question}\n\n{opts_msg}\n\n{explainer}\n> "

    choice_value = None
    valid_choice = False
    while not valid_choice:
        choice = input(msg)
        choice_value = choice_map.get(choice)
        valid_choice = choice_value is not None
        if not valid_choice:
            print('Please choose from the available options.')
            msg = "> "

    return choice_value


def run_with_verbosity(func: Callable, args: Namespace):
    """
    Run a function with output to stdout, or piped to devnull, depending on the ``verbose`` and ``dry_run``
    parameters passed via ``args``.

    :param func: The function to call with the arguments.
    :param args: The argument namespace, must include ``verbose`` and ``dry_run`` parameters.
    """
    dry_run = args.dry_run

    global verbose
    verbose = int(max(args.verbose, dry_run))

    orig_stdout = sys.stdout
    null_path = Path(os.devnull)

    try:
        with null_path.open("w") as devnull:
            if not verbose:
                sys.stdout = devnull
            func(args)
    except Exception as e:
        exit(e)
    finally:
        sys.stdout = orig_stdout
